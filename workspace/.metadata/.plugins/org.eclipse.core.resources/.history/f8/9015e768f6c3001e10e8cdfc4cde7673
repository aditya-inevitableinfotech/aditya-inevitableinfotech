package Controller;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.net.URL;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.TimeUnit;

import org.openqa.selenium.By;
import org.openqa.selenium.remote.DesiredCapabilities;
import org.testng.IReporter;
import org.testng.ISuite;
import org.testng.ISuiteResult;
import org.testng.ITestContext;
import org.testng.ITestResult;
import org.testng.Reporter;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;
import org.testng.collections.Lists;
import org.testng.internal.Utils;
import org.testng.log4testng.Logger;
import org.testng.xml.XmlSuite;

import io.appium.java_client.AppiumDriver;
import io.appium.java_client.MobileElement;
import io.appium.java_client.TouchAction;
import io.appium.java_client.android.Activity;
import io.appium.java_client.android.AndroidDriver;
import io.appium.java_client.android.StartsActivity;
import io.appium.java_client.android.nativekey.AndroidKey;
import io.appium.java_client.android.nativekey.KeyEvent;
import io.appium.java_client.remote.AndroidMobileCapabilityType;
import io.appium.java_client.remote.MobileCapabilityType;
import io.appium.java_client.touch.WaitOptions;
import io.appium.java_client.touch.offset.PointOption;
	
	public class I2C_GPIO_Automation implements IReporter {

	/**
	 * Reporter that generates a single-page HTML report of the suite test results.
	 * <p>
	 * Based on TestNG built-in implementation: org.testng.reporters.EmailableReporter2
	 * </p>
	 */

		static AppiumDriver<MobileElement> driver;
	    private static final Logger LOG = Logger.getLogger(I2C_GPIO_Automation.class);
	    private static String timeZone = "GMT+0530"; 
	    private static SimpleDateFormat sdfdate = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss a");
	    private static SimpleDateFormat sdftime = new SimpleDateFormat("HH:mm:ss a");
	    private static String outFilename = "custom-report.html";
	    private static NumberFormat integerFormat = NumberFormat.getIntegerInstance();
	    private static NumberFormat decimalFormat = NumberFormat.getNumberInstance();
	    protected PrintWriter writer;
	    protected List<SuiteResult> suiteResults = Lists.newArrayList();
	    private StringBuilder buffer = new StringBuilder();

	    @BeforeMethod
	    public void setup() {

	        try {
	            DesiredCapabilities dc = new DesiredCapabilities();

	            dc.setCapability(MobileCapabilityType.AUTOMATION_NAME, "APPIUM");
	            dc.setCapability("appium-version", "1.22.3");
	            dc.setCapability(MobileCapabilityType.DEVICE_NAME, "sb52");
	            dc.setCapability(MobileCapabilityType.PLATFORM_NAME, "Android");
	            dc.setCapability(MobileCapabilityType.PLATFORM_VERSION, "12");
	            
	            DeviceInfo deviceInfo = getConnectedDeviceInfo();
	            if (deviceInfo != null) {
	                System.out.println("Connected device UDID: " + deviceInfo.getDeviceUDID());
	                System.out.println("Connected device Name: " + deviceInfo.getDeviceName());
	            } else {
	            	System.out.println("No devices connected. Please Check your Connectivity!");
	                System.exit(0);
	            }        
	        
	            dc.setCapability(MobileCapabilityType.AUTOMATION_NAME, "UiAutomator2");
	            dc.setCapability(MobileCapabilityType.NO_RESET, "true");
	            dc.setCapability(MobileCapabilityType.FULL_RESET, "false");
	            dc.setCapability("uiautomator2ServerInstallTimeout", 9000);
	            dc.setCapability("uiautomator2ServerLaunchTimeout", 9000);
	            dc.setCapability(MobileCapabilityType.NEW_COMMAND_TIMEOUT, 2000);
	            dc.setCapability("automationName", "uiautomator2");
	            dc.setCapability("skipServerInstallation", false);
	            dc.setCapability("adbExecTimeout", 5000);
	            dc.setCapability("clearSystemFiles", true);
	            dc.setCapability("appWaitForLaunch", false);
	            dc.setCapability("suppressKillServer", true);
	            dc.setCapability("autoGrantPermissions", "true");
	            dc.setCapability("appWaitPackage", "io.appium.settings");
	            dc.setCapability("appWaitActivity", "io.appium.settings.Settings");
	            dc.setCapability(AndroidMobileCapabilityType.AUTO_GRANT_PERMISSIONS, true);
	            dc.setCapability(MobileCapabilityType.CLEAR_SYSTEM_FILES, true);

	            URL url = new URL("http://127.0.0.1:4723/wd/hub");
	            driver = new AndroidDriver<MobileElement>(url, dc);
	            driver.manage().timeouts().implicitlyWait(300, TimeUnit.SECONDS);

	        } catch (Exception exp) {
	            System.out.println("Cause is : " + exp.getCause());
	            System.out.println("Message is : " + exp.getMessage());
	            exp.printStackTrace();
	        }
	    }

	    public static DeviceInfo getConnectedDeviceInfo() {
	        try {
	            Process process = Runtime.getRuntime().exec("adb devices");
	            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
	            String line;
	            while ((line = reader.readLine()) != null) {
	                if (line.endsWith("device")) {
	                    String[] deviceInfo = line.split("\\s+");
	                    String deviceName = deviceInfo[0];

	                    // Execute adb shell getprop ro.product.model command
	                    Process Process1 = Runtime.getRuntime().exec("adb -s " + deviceName + " shell getprop ro.product.model");
	                    BufferedReader Reader1 = new BufferedReader(new InputStreamReader(Process1.getInputStream()));
	                    String modelName = Reader1.readLine();
	                    Reader1.close();

	                    reader.close();
	                    return new DeviceInfo(deviceName, modelName);
	                }
	            }
	            reader.close();
	        } catch (IOException e) {
	            e.printStackTrace();
	        }
	        return null;
	    }

	static class DeviceInfo {
	    private final String deviceUDID;
	    private final String deviceName;

	    public DeviceInfo(String deviceName, String deviceUDID) {
	        this.deviceUDID = deviceUDID;
	        this.deviceName = deviceName;
	    }

	    public String getDeviceUDID() {
	        return deviceUDID;
	    }

	    public String getDeviceName() {
	        return deviceName;
	    }
	}
		

    @SuppressWarnings("resource")
	@Test(invocationCount = 1)
    public void ControllerGPIOI2CTesting() throws InterruptedException, IOException {

        System.out.println("--------> Controller GPIO I2C Testing is Started <--------");

        // Unlock device
        ((AndroidDriver<MobileElement>) driver).lockDevice();
        ((AndroidDriver<MobileElement>) driver).unlockDevice();

        // Swipe up
        Swipeup();
        
        // Enter PIN
        driver.findElement(By.id("com.android.systemui:id/pinEntry")).click();
        enterPin("2024"); // Replace with your PIN
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

        // Start the app
        ((StartsActivity) driver).startActivity(new Activity("com.inevitable.controller", "com.inevitable.controller.MainActivity"));
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
        
        // Navigate to GPIO settings
        driver.findElement(By.id("com.inevitable.controller:id/setting_button_gpio")).click();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
        
        // Navigate to GPIO pins
        driver.findElement(By.id("com.inevitable.controller:id/gpio_pins")).click();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

        // Find all the dropdown items
        List<MobileElement> dropdownItems = driver.findElements(By.xpath("//android.widget.TextView"));

        // Display the list to the user
        System.out.println("Choose a GPIO pin to connect:");
        int displayedIndex = 1;
        for (int i = 0; i < dropdownItems.size(); i++) {
            String pinText = dropdownItems.get(i).getText();
            if (!pinText.equals("None")&&!pinText.equals("GPIO 17") && !pinText.equals("GPIO 58")) {
                System.out.println((displayedIndex) + ". " + pinText);
                displayedIndex++;
            }
        }

        // Ask the user to connect a pin
        Scanner scanner = new Scanner(System.in);
        System.out.println("Choose 0 To EXIT From The App!");
        System.out.print("Enter the number of the pin to connect: ");
        int selectedPinNumber = scanner.nextInt();

        // Map for mapping selected pin number to new pin number
        Map<Integer, Integer> pinNumberMapping = new HashMap<>();
        pinNumberMapping.put(1, 1);
        pinNumberMapping.put(2, 3);
        pinNumberMapping.put(3, 4);
        pinNumberMapping.put(4, 5);
        pinNumberMapping.put(5, 6);
        pinNumberMapping.put(6, 8);

        // Validate and map the user input
        if (pinNumberMapping.containsKey(selectedPinNumber)) {
            selectedPinNumber = pinNumberMapping.get(selectedPinNumber);
        } else if (selectedPinNumber == 0) {
         
            // Navigate back
            navigateBack();
            navigateBack();
            navigateBack();

            // Confirm action
            driver.findElement(By.id("android:id/button1")).click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

            // Lock device
            ((AndroidDriver<MobileElement>) driver).lockDevice();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
            System.exit(0);
	        } else {
	            System.out.println("Invalid pin number. Please choose a valid pin number.");
	            scanner.close();
	            return; // Exit the program or return to the calling method
	        }

        // Click on the selected item
        MobileElement selectedPin = dropdownItems.get(selectedPinNumber);
        String pinText = selectedPin.getText();
        System.out.println("Selected Pin is:" + pinText);
        selectedPin.click();

	     // Handle specific actions based on the selected pin and return the toggled GPIO pin number
	     int toggledGPIOPin = 0; // Default value
	     switch (pinText) {
	     
         case "GPIO 16":
             System.out.println("Toggle GPIO to pin 35 and press Enter when done.");
             scanner.nextLine(); // Consume newline
             scanner.nextLine(); // Wait for user input (Enter key)
             toggledGPIOPin = 35;
             break;
             
         case "GPIO 31":
             System.out.println("Toggle GPIO to pin 7 and press Enter when done.");
             scanner.nextLine(); // Consume newline
             scanner.nextLine(); // Wait for user input (Enter key)
             toggledGPIOPin = 7;
             break;
             
         case "GPIO 55":
             System.out.println("Toggle GPIO to pin 11 and press Enter when done.");
             scanner.nextLine(); // Consume newline
             scanner.nextLine(); // Wait for user input (Enter key)
             toggledGPIOPin = 11;
             break;
             
         case "GPIO 56":
             System.out.println("Toggle GPIO to pin 13 and press Enter when done.");
             scanner.nextLine(); // Consume newline
             scanner.nextLine(); // Wait for user input (Enter key)
             toggledGPIOPin = 13;
             break;
             
         case "GPIO 57":
             System.out.println("Toggle GPIO to pin 29 and press Enter when done.");
             scanner.nextLine(); // Consume newline
             scanner.nextLine(); // Wait for user input (Enter key)
             toggledGPIOPin = 29;
             break;
             
         case "GPIO 86":
             System.out.println("Toggle GPIO to pin 37 and press Enter when done.");
             scanner.nextLine(); // Consume newline
             scanner.nextLine(); // Wait for user input (Enter key)
             toggledGPIOPin = 37;
             break;

         default:
             System.out.println("Pin connected successfully!");
	     }
	
	     // Output the toggled GPIO pin number
	     if (toggledGPIOPin != 0) {
	         System.out.println("Toggled GPIO pin number: " + toggledGPIOPin);
	     } else {
	         System.out.println("Pin connected successfully!");
	     }


	     // Export GPIO pin
	     driver.findElement(By.id("com.inevitable.controller:id/gpioexport_button")).click();
	     driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

	     // Navigate to GPIO directions
	     driver.findElement(By.id("com.inevitable.controller:id/gpio_directions")).click();
	     driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

	     // Navigate to OUT directions
	     driver.findElement(By.xpath("//android.widget.TextView[@text='out']")).click();
	     driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
        
	     // Navigate to GPIO values
	     driver.findElement(By.id("com.inevitable.controller:id/gpio_values")).click();
	     driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
        
	     // Navigate to GPIO value 1
	     driver.findElement(By.xpath("//android.widget.TextView[@text='1']")).click();
	     driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

	     // Submit GPIO changes
	     driver.findElementByXPath("//android.widget.Button[@text='SUBMIT']").click();
	     driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

        // For High Value
        // Ask the user a question
        System.out.println("Did you see the LED glowing? [Y/n]");

        // Read user input
        String userInput = scanner.nextLine();

        // Check the user's response
        if (userInput.equalsIgnoreCase("Y")) {
            System.out.println("Great! The LED is glowing.");
        } else if (userInput.equalsIgnoreCase("n")) {
            System.out.println("Please check your connection (physical pin mapping on the board) and press Enter when done.");
            scanner.nextLine(); // Wait for user input (Enter key)

            System.out.println("I am trying again.. Please wait!");
            // Navigate to GPIO pins
            driver.findElement(By.id("com.inevitable.controller:id/gpio_pins")).click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
            handleGPIOValues(selectedPinNumber);

            // Export GPIO pin
            driver.findElement(By.id("com.inevitable.controller:id/gpioexport_button")).click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

            // Navigate to GPIO directions
            driver.findElement(By.id("com.inevitable.controller:id/gpio_directions")).click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

            // Navigate to OUT directions
            driver.findElement(By.xpath("//android.widget.TextView[@text='out']")).click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

            // Navigate to GPIO values
            driver.findElement(By.id("com.inevitable.controller:id/gpio_values")).click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

            // Navigate to GPIO value 1
            driver.findElement(By.xpath("//android.widget.TextView[@text='1']")).click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

            // Submit GPIO changes
            driver.findElementByXPath("//android.widget.Button[@text='SUBMIT']").click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

            // Ask Again
            System.out.println("Did you see the LED glowing [Y/n]");

            // Read user input
            String userInputs = scanner.nextLine();

            // Check the user's response
            if (userInputs.equalsIgnoreCase("Y")) {
                System.out.println("Great! The LED is glowing.");
            } else if (userInputs.equalsIgnoreCase("n")) {
                System.out.println("It seems there is some critical issue. Exiting!");

                // Navigate back
                navigateBack();
                navigateBack();

                // Confirm action
                driver.findElement(By.id("android:id/button1")).click();
                driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

                // Lock device
                ((AndroidDriver<MobileElement>) driver).lockDevice();
                driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
                System.exit(0);
            } else {
                while (!userInputs.equalsIgnoreCase("Y") && !userInputs.equalsIgnoreCase("n")) {
                    System.out.println("Invalid input. Please enter 'Y' or 'n'.");
                    System.out.print("Enter your choice [Y/n]: ");
                    userInputs = scanner.nextLine();
                }
            }
        } else {
            while (!userInput.equalsIgnoreCase("Y") && !userInput.equalsIgnoreCase("n")) {
                System.out.println("Invalid input. Please enter 'Y' or 'n'.");
                System.out.print("Enter your choice [Y/n]: ");
                userInput = scanner.nextLine();
            }
        }
        
        // Read GPIO pins
        driver.findElementByXPath("//android.widget.TextView[@text='Read']").click();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

        // Handling GPIO values based on the selected GPIO pin.
        driver.findElement(By.id("com.inevitable.controller:id/readpins_spinner")).click();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

        // Handle GPIO values based on the previously selected GPIO pin
        handleGPIOValues(selectedPinNumber);
        
        // Read Output
        driver.findElementByXPath("//android.widget.Button[@text='READ']").click();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
        
        // For Low Value
        // Navigate to GPIO settings
        driver.findElementByXPath("//android.widget.TextView[@text='Write']").click();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
        
        // Navigate to GPIO values
        driver.findElement(By.id("com.inevitable.controller:id/gpio_values")).click();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
        
        // Navigate to GPIO value 0
        driver.findElement(By.xpath("//android.widget.TextView[@text='0']")).click();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000); 
        
        // Submit GPIO changes
        driver.findElementByXPath("//android.widget.Button[@text='SUBMIT']").click();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
        
        // Ask the user a question
        System.out.println("Did you see the LED glowing off? [Y/n]");
        
        // Read user input
        String userInput1 = scanner.nextLine();

        // Check the user's response
        if (userInput1.equalsIgnoreCase("Y")) {
            System.out.println("Great! The LED is glowing off.");
        } else if (userInput1.equalsIgnoreCase("n")) {
            System.out.println("Please check your connection (physical pin mapping on the board) and press Enter when done.");
            scanner.nextLine(); // Wait for user input (Enter key)

            System.out.println("I am trying again.. Please wait!");
            // Navigate to GPIO pins
            driver.findElement(By.id("com.inevitable.controller:id/gpio_pins")).click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
            handleGPIOValues(selectedPinNumber);

            // Export GPIO pin
            driver.findElement(By.id("com.inevitable.controller:id/gpioexport_button")).click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

            // Navigate to GPIO directions
            driver.findElement(By.id("com.inevitable.controller:id/gpio_directions")).click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

            // Navigate to OUT directions
            driver.findElement(By.xpath("//android.widget.TextView[@text='out']")).click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

            // Navigate to GPIO values
            driver.findElement(By.id("com.inevitable.controller:id/gpio_values")).click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

            // Navigate to GPIO value 1
            driver.findElement(By.xpath("//android.widget.TextView[@text='0']")).click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

            // Submit GPIO changes
            driver.findElementByXPath("//android.widget.Button[@text='SUBMIT']").click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

            // Ask Again
            System.out.println("Did you see the LED glowing off? [Y/n]");

            // Read user input
            String userInputs = scanner.nextLine();

            // Check the user's response
            if (userInputs.equalsIgnoreCase("Y")) {
                System.out.println("Great! The LED is not glowing.");
            } else if (userInputs.equalsIgnoreCase("n")) {
                System.out.println("It seems there is some critical issue. Exiting!");

                // Navigate back
                navigateBack();
                navigateBack();

                // Confirm action
                driver.findElement(By.id("android:id/button1")).click();
                driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

                // Lock device
                ((AndroidDriver<MobileElement>) driver).lockDevice();
                driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
                System.exit(0);
                
            } else {
                while (!userInputs.equalsIgnoreCase("Y") && !userInputs.equalsIgnoreCase("n")) {
                    System.out.println("Invalid input. Please enter 'Y' or 'n'.");
                    System.out.print("Enter your choice [Y/n]: ");
                    userInputs = scanner.nextLine();
                }
            }
        } else {
            while (!userInput1.equalsIgnoreCase("Y") && !userInput1.equalsIgnoreCase("n")) {
                System.out.println("Invalid input. Please enter 'Y' or 'n'.");
                System.out.print("Enter your choice [Y/n]: ");
                userInput1 = scanner.nextLine();
            }
        }
        
        // Read GPIO pins
        driver.findElementByXPath("//android.widget.TextView[@text='Read']").click();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

        // Handling GPIO values based on the selected GPIO pin.
        driver.findElement(By.id("com.inevitable.controller:id/readpins_spinner")).click();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

        // Handle GPIO values based on the previously selected GPIO pin
        handleGPIOValues(selectedPinNumber);
        
        // Read Output
        driver.findElementByXPath("//android.widget.Button[@text='READ']").click();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
        
        // Navigate back
        navigateBack();

        System.out.println("--------> Controller GPIO Testing is Executed Successfully on ORCA <--------");
	    
	    try {
            System.out.println("------> Controller I2C Testing is Started <------");
	        
            // Navigate to I2C settings
            driver.findElement(By.id("com.inevitable.controller:id/setting_button_i2c")).click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
            
            // Navigate I2C Bus
            driver.findElement(By.id("com.inevitable.controller:id/i2c_bus")).click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

            // Export to I2C pins
            List<MobileElement> dropdownItem = driver.findElements(By.xpath("//android.widget.TextView"));
            Random rand = new Random();
            int randomIndex = rand.nextInt(dropdownItem.size());
            dropdownItem.get(randomIndex).click();

            // Navigate Device Address
            driver.findElement(By.id("com.inevitable.controller:id/device_address")).click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

            // Handle GPIO values based on random selection
            handleGPIOValues();

            // Input random string
            inputRandomString();

            // Navigate back
            navigateBack();
            navigateBack();
            navigateBack();
            
            // Confirm action
            driver.findElement(By.id("android:id/button1")).click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

            // Lock device
            ((AndroidDriver<MobileElement>) driver).lockDevice();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

            System.out.println("------> Controller GPIO I2C Testing Executed Successfully on ORCA <------");
	    
	    } catch (Exception exp) {
            exp.printStackTrace();
	    }
        }
	
	@SuppressWarnings("rawtypes")
	private void Swipeup() throws InterruptedException {
		// TODO Auto-generated method stub
		TouchAction action = new TouchAction(driver);
        org.openqa.selenium.Dimension size = driver.manage().window().getSize();
        int width = size.width;
        int height = size.height;
        int middleOfX = width / 2;
        int startYCoordinate = (int) (height * 0.80);
        int endYCoordinate = (int) (height * 0.20);
        action.press(PointOption.point(middleOfX, startYCoordinate))
                .waitAction(WaitOptions.waitOptions(Duration.ofSeconds(1)))
                .moveTo(PointOption.point(middleOfX, endYCoordinate)).release().perform();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);

	}

	private static void handleGPIOValues(int selectedPinNumber) {
	    // Find the menu item based on the previously selected GPIO pin text
	    MobileElement menuItem = driver.findElement(By.xpath("//android.widget.TextView[@index='" + selectedPinNumber + "']"));
	    // Get the selected pin number to a String and print it
	    List<MobileElement> dropdownItems = driver.findElements(By.xpath("//android.widget.TextView"));
	    String pinText = dropdownItems.get(selectedPinNumber).getText();
	    System.out.println("Selected Pin is: " + pinText);
	    toggleMenuItem(menuItem);
	}

	private static void toggleMenuItem(MobileElement menuItem) {
	    if (menuItem != null) {
	        if (!menuItem.getAttribute("checked").equals("true")) {
	            menuItem.click();
	            System.out.println("Toggled on.");
	        } else {
	            menuItem.click();
	            System.out.println("Toggled off.");
	        }
	    } else {
	        System.out.println("Menu item not found.");
	    }
	}

private void inputRandomString() throws InterruptedException {
    	
        String randomString = generateRandomString();
        driver.findElement(By.id("com.inevitable.controller:id/input_string")).sendKeys(randomString);
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
        driver.findElement(By.xpath("//android.widget.Button[@text='SUBMIT']")).click();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
        driver.findElement(By.xpath("//android.widget.FrameLayout[@content-desc='SCAN']")).click();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
        scrollDown();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(10000);
        
        System.out.println("--------> Controller I2C Testing is Executed Successfully on ORCA <--------");
        
    }
	
	@SuppressWarnings("rawtypes")
	private void scrollDown() throws InterruptedException {
	// TODO Auto-generated method stub
		TouchAction action = new TouchAction(driver);
        org.openqa.selenium.Dimension size = driver.manage().window().getSize();
        int width = size.width;
        int height = size.height;
        int middleOfX = width / 2;
        int startYCoordinate = (int) (height * 0.20);
        int endYCoordinate = (int) (height * 0.80);
        action.press(PointOption.point(middleOfX, startYCoordinate))
                .waitAction(WaitOptions.waitOptions(Duration.ofSeconds(10)))
                .moveTo(PointOption.point(middleOfX, endYCoordinate)).release().perform();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);Thread.sleep(2000);
	}

	private String generateRandomString() {
        // Define the characters that can be part of the random string
        String allowedCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890+\\{}[]-!@#$%^&*()~`;:'.,?/|";

        // Set the length of the random string
        int length = 20;

        StringBuilder randomString = new StringBuilder();
        Random random = new Random();

        // Generate a random string by selecting characters randomly from the allowed characters
        for (int i = 0; i < length; i++) {
            int randomIndex = random.nextInt(allowedCharacters.length());
            randomString.append(allowedCharacters.charAt(randomIndex));
        }

        return randomString.toString();
    }

	private void enterPin(String pin) {
        for (char digit : pin.toCharArray()) {
            driver.findElement(By.id("com.android.systemui:id/key" + digit)).click();
        }
        driver.findElement(By.id("com.android.systemui:id/key_enter")).click();
    }

    private void handleGPIOValues() throws InterruptedException {
        Random random = new Random();
        List<MobileElement> dropdownItems3 = driver.findElements(By.xpath("//android.widget.TextView"));

        // Randomly select an item
        int randomIndex3 = random.nextInt(dropdownItems3.size());
        dropdownItems3.get(randomIndex3).click();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
        Thread.sleep(2000);

        // Check if the selected item is the second item
        if (randomIndex3 == 1) {
            // Execute code for the second item
            
            driver.findElement(By.id("com.inevitable.controller:id/gpio_values")).click();

            // Update the dropdownItems list after clicking on gpio_values
            dropdownItems3 = driver.findElements(By.xpath("//android.widget.TextView"));

            Random random1 = new Random();
            int randomIndex4 = random1.nextInt(dropdownItems3.size());
            dropdownItems3.get(randomIndex4).click();
            driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
            Thread.sleep(2000);
        }
    }

    @SuppressWarnings({ "rawtypes" })
	private void navigateBack() throws InterruptedException {
        ((AndroidDriver) driver).pressKey(new KeyEvent(AndroidKey.BACK));
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
        Thread.sleep(2000);
    }
		
	    public void generateReport(List<XmlSuite> xmlSuites, List<ISuite> suites,
	                               String outputDirectory) {
	        try {
	            writer = createWriter(outputDirectory);
	        } catch ( IOException e ) {
	            LOG.error( "Unable to create output file", e );
	            return;
	        }
	        for ( ISuite suite : suites ) {
	            suiteResults.add( new SuiteResult( suite ) );
	        }

	        writeDocumentStart();
	        writeHead();
	        writeBody();
	        writeDocumentEnd();

	        writer.close();
	    }

	    protected PrintWriter createWriter(String outdir) throws IOException {
	        new File(outdir).mkdirs();
	        return new PrintWriter( new BufferedWriter( new FileWriter( new File( outdir, outFilename ) ) ) );
	    }

	    protected void writeDocumentStart() {
	        writer.println("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">");
	        writer.print("<html xmlns=\"http://www.w3.org/1999/xhtml\">");
	    }

	    protected void writeHead() {
	        writer.print("<head>");
	        writer.print("<title>ORCA board Features Automation Report</title>");
	        writeStylesheet();
	        writer.print("</head>");
	    }

	    protected void writeStylesheet() {
	        writer.print("<style type=\"text/css\">");
	        writer.print("table {margin-bottom:10px;border-collapse:collapse;empty-cells:show}");
	        writer.print("th,td {border:1px solid #009;padding:.25em .5em}");
	        writer.print("th {vertical-align:bottom}");
	        writer.print("td {vertical-align:top}");
	        writer.print("table a {font-weight:bold}");
	        writer.print(".stripe td {background-color: #E6EBF9}");
	        writer.print(".num {text-align:right}");
	        writer.print(".passedodd td {background-color: #3F3}");
	        writer.print(".passedeven td {background-color: #0A0}");
	        writer.print(".skippedodd td {background-color: #DDD}");
	        writer.print(".skippedeven td {background-color: #CCC}");
	        writer.print(".failedodd td,.attn {background-color: #F33}");
	        writer.print(".failedeven td,.stripe .attn {background-color: #D00}");
	        writer.print(".stacktrace {white-space:pre;font-family:monospace}");
	        writer.print(".totop {font-size:85%;text-align:center;border-bottom:2px solid #000}");
	        writer.print("</style>");
	    }

	    protected void writeBody() {
	        writer.print("<body>");
	        writeReportTitle( "ORCA board Features Automation Report" );
	        writeSuiteSummary();
	        writeScenarioSummary();
	        writeScenarioDetails();
	        writer.print("</body>");
	    }

	    protected void writeReportTitle( String title ) {
	        writer.print( "<center><h1>" + title + " - " + getDateAsString() + "</h1></center>" );
	    }

	    protected void writeDocumentEnd() {
	        writer.print("</html>");
	    }

	    protected void writeSuiteSummary() {

	        int totalPassedTests = 0;
	        int totalSkippedTests = 0;
	        int totalFailedTests = 0;
	        long totalDuration = 0;

	        writer.print("<table>");
	        writer.print("<tr>");
	        writer.print("<th>Test</th>");
	        writer.print("<th># Passed</th>");
	        writer.print("<th># Skipped</th>");
	        writer.print("<th># Failed</th>");
	        writer.print("<th>Seconds</th>");
	        writer.print("<th>Included Groups</th>");
	        writer.print("<th>Excluded Groups</th>");
	        writer.print("</tr>");

	        int testIndex = 0;
	        for ( SuiteResult suiteResult : suiteResults ) {
	            writer.print("<tr><th colspan=\"7\">");
	            writer.print( Utils.escapeHtml( suiteResult.getSuiteName() ) );
	            writer.print("</th></tr>");

	            for ( TestResult testResult : suiteResult.getTestResults() ) {
	                int passedTests = testResult.getPassedTestCount();
	                int skippedTests = testResult.getSkippedTestCount();
	                int failedTests = testResult.getFailedTestCount();
	                long duration = testResult.getDuration();

	                writer.print("<tr");
	                if ((testIndex % 2) == 1) {
	                    writer.print(" class=\"stripe\"");
	                }
	                writer.print(">");

	                buffer.setLength(0);
	                writeTableData( buffer.append("<a href=\"#t").append(testIndex).append("\">")
	                    .append(Utils.escapeHtml(testResult.getTestName())).append("</a>").toString());
	                writeTableData( integerFormat.format(passedTests), "num");
	                writeTableData( integerFormat.format(skippedTests), (skippedTests > 0 ? "num attn" : "num"));
	                writeTableData( integerFormat.format(failedTests), (failedTests > 0 ? "num attn" : "num"));
	                writeTableData( decimalFormat.format(millisecondsToSeconds(duration)), "num");
	                writeTableData( testResult.getIncludedGroups() );
	                writeTableData( testResult.getExcludedGroups() );

	                writer.print("</tr>");

	                totalPassedTests += passedTests;
	                totalSkippedTests += skippedTests;
	                totalFailedTests += failedTests;
	                totalDuration += duration;

	                testIndex++;
	            }
	        }

	        // Print totals if there was more than one test
	        if ( testIndex >= 1 ) {
	            writer.print("<tr>");
	            writer.print("<th>Total</th>");
	            writeTableHeader( integerFormat.format(totalPassedTests), "num");
	            writeTableHeader( integerFormat.format(totalSkippedTests), (totalSkippedTests > 0 ? "num attn" : "num"));
	            writeTableHeader( integerFormat.format(totalFailedTests), (totalFailedTests > 0 ? "num attn" : "num"));
	            writeTableHeader( decimalFormat.format(millisecondsToSeconds(totalDuration)), "num");
	            writer.print("<th colspan=\"2\"></th>");
	            writer.print("</tr>");
	        }

	        writer.print("</table>");
	    }

	    /**
	     * Writes a summary of all the test scenarios.
	     */
	    protected void writeScenarioSummary() {
	        writer.print("<table>");
	        writer.print("<thead>");
	        writer.print("<tr>");
	        writer.print("<th>Class</th>");
	        writer.print("<th>Method</th>");
	        writer.print("<th>Name</th>");
	        writer.print("<th>Start</th>");
	        writer.print("<th>Seconds</th>");
	        writer.print("</tr>");
	        writer.print("</thead>");

	        int testIndex = 0;
	        int scenarioIndex = 0;
	        for ( SuiteResult suiteResult : suiteResults ) {
	            writer.print("<tbody><tr><th colspan=\"5\">");
	            writer.print( Utils.escapeHtml( suiteResult.getSuiteName() ) );
	            writer.print("</th></tr></tbody>");

	            for ( TestResult testResult : suiteResult.getTestResults() ) {
	                writer.print("<tbody id=\"t");
	                writer.print(testIndex);
	                writer.print("\">");

	                String testName = Utils.escapeHtml( testResult.getTestName() );

	                scenarioIndex += writeScenarioSummary(testName
	                        + " &#8212; failed (configuration methods)",
	                        testResult.getFailedConfigurationResults(), "failed",
	                        scenarioIndex
	                );
	                scenarioIndex += writeScenarioSummary(testName
	                        + " &#8212; failed", testResult.getFailedTestResults(),
	                        "failed", scenarioIndex
	                );
	                scenarioIndex += writeScenarioSummary(testName
	                        + " &#8212; skipped (configuration methods)",
	                        testResult.getSkippedConfigurationResults(), "skipped",
	                        scenarioIndex
	                );
	                scenarioIndex += writeScenarioSummary(testName
	                        + " &#8212; skipped",
	                        testResult.getSkippedTestResults(), "skipped",
	                        scenarioIndex
	                );
	                scenarioIndex += writeScenarioSummary(testName
	                        + " &#8212; passed", testResult.getPassedTestResults(),
	                        "passed", scenarioIndex
	                );

	                writer.print("</tbody>");

	                testIndex++;
	            }
	        }

	        writer.print("</table>");
	    }

	    /**
	     * Writes the scenario summary for the results of a given state for a single
	     * test.
	     */
	    private int writeScenarioSummary( String description, List<ClassResult> classResults,
	                                     String cssClassPrefix, int startingScenarioIndex ) {
	        int scenarioCount = 0;
	        if (!classResults.isEmpty()) {
	            writer.print("<tr><th colspan=\"5\">");
	            writer.print(description);
	            writer.print("</th></tr>");

	            int scenarioIndex = startingScenarioIndex;
	            int classIndex = 0;
	            for ( ClassResult classResult : classResults ) {
	                String cssClass = cssClassPrefix + ((classIndex % 2) == 0 ? "even" : "odd");

	                buffer.setLength(0);

	                int scenariosPerClass = 0;
	                int methodIndex = 0;
	                for ( MethodResult methodResult : classResult.getMethodResults() ) {
	                    List<ITestResult> results = methodResult.getResults();
	                    int resultsCount = results.size();
	                    assert resultsCount > 0;

	                    ITestResult aResult = results.iterator().next();
	                    String methodName = Utils.escapeHtml(aResult.getMethod().getMethodName());
	                    long start = aResult.getStartMillis();
	                    long duration = aResult.getEndMillis() - start;

	                    // The first method per class shares a row with the class
	                    // header
	                    if (methodIndex > 0) {
	                        buffer.append("<tr class=\"").append(cssClass)
	                                .append("\">");

	                    }

	                    // Write the timing information with the first scenario per method
	                    buffer.append("<td><a href=\"#m").append(scenarioIndex)
	                            .append("\">").append( methodName + "</a></td>" )
	                            .append( "<td rowspan=\"1\">" + aResult.getName() + "</td>" )
	                            .append( "<td rowspan=\"")
	                            .append(resultsCount).append("\">").append( parseUnixTimeToTimeOfDay(start) )
	                            .append( "</td>").append("<td rowspan=\"" )
	                            .append(resultsCount).append("\">")
	                            .append( decimalFormat.format( millisecondsToSeconds( duration ) ) ).append("</td></tr>");
	                    scenarioIndex++;

	                    // Write the remaining scenarios for the method
	                    for ( int i = 1; i < resultsCount; i++ ) {
	                        buffer.append("<tr class=\"").append(cssClass)
	                                .append("\">").append("<td><a href=\"#m")
	                                .append(scenarioIndex).append("\">")
	                                .append( methodName + "</a></td>" )
	                                .append("<td rowspan=\"1\">" + aResult.getName() + "</td></tr>" );
	                        scenarioIndex++;
	                    }

	                    scenariosPerClass += resultsCount;
	                    methodIndex++;
	                }

	                // Write the test results for the class
	                writer.print("<tr class=\"");
	                writer.print(cssClass);
	                writer.print("\">");
	                writer.print("<td rowspan=\"");
	                writer.print(scenariosPerClass);
	                writer.print("\">");
	                writer.print(Utils.escapeHtml(classResult.getClassName()));
	                writer.print("</td>");
	                writer.print(buffer);

	                classIndex++;
	            }
	            scenarioCount = scenarioIndex - startingScenarioIndex;
	        }
	        return scenarioCount;
	    }

	    /**
	     * Writes the details for all test scenarios.
	     */
	    protected void writeScenarioDetails() {
	        int scenarioIndex = 0;
	        for ( SuiteResult suiteResult : suiteResults ) {
	            for ( TestResult testResult : suiteResult.getTestResults() ) {
	                writer.print("<h2>");
	                writer.print( Utils.escapeHtml( testResult.getTestName() ) );
	                writer.print("</h2>");

	                scenarioIndex += writeScenarioDetails(
	                        testResult.getFailedConfigurationResults(), scenarioIndex);
	                scenarioIndex += writeScenarioDetails(
	                        testResult.getFailedTestResults(), scenarioIndex);
	                scenarioIndex += writeScenarioDetails(
	                        testResult.getSkippedConfigurationResults(), scenarioIndex);
	                scenarioIndex += writeScenarioDetails(
	                        testResult.getSkippedTestResults(), scenarioIndex);
	                scenarioIndex += writeScenarioDetails(
	                        testResult.getPassedTestResults(), scenarioIndex);
	            }
	        }
	    }

	    /**
	     * Writes the scenario details for the results of a given state for a single
	     * test.
	     */
	    private int writeScenarioDetails( List<ClassResult> classResults, int startingScenarioIndex ) {
	        int scenarioIndex = startingScenarioIndex;
	        for ( ClassResult classResult : classResults ) {
	            String className = classResult.getClassName();
	            for ( MethodResult methodResult : classResult.getMethodResults() ) {
	                List<ITestResult> results = methodResult.getResults();
	                assert !results.isEmpty();

	                ITestResult mResult = results.iterator().next();
	                String label = Utils.escapeHtml( className + "#"
	                     + mResult.getMethod().getMethodName() + " ( " + mResult.getName() +" )" );
	                for ( ITestResult result : results ) {
	                    writeScenario( scenarioIndex, label, result );
	                    scenarioIndex++;
	                }
	            }
	        }

	        return scenarioIndex - startingScenarioIndex;
	    }

	    /**
	     * Writes the details for an individual test scenario.
	     */
	    private void writeScenario(int scenarioIndex, String label,
	                               ITestResult result) {
	        writer.print("<h3 id=\"m");
	        writer.print(scenarioIndex);
	        writer.print("\">");
	        writer.print(label);
	        writer.print("</h3>");

	        writer.print("<table class=\"result\">");

	        // Write test parameters (if any)
	        Object[] parameters = result.getParameters();
	        int parameterCount = (parameters == null ? 0 : parameters.length);
	        if (parameterCount > 0) {
	            writer.print("<tr class=\"param\">");
	            for (int i = 1; i <= parameterCount; i++) {
	                writer.print("<th>Parameter #");
	                writer.print(i);
	                writer.print("</th>");
	            }
	            writer.print("</tr><tr class=\"param stripe\">");
	            for (Object parameter : parameters) {
	                writer.print("<td>");
	                writer.print( Utils.escapeHtml( Utils.toString( parameter, Object.class ) ) );
	                writer.print("</td>");
	            }
	            writer.print("</tr>");
	        }

	        // Write reporter messages (if any)
	        List<String> reporterMessages = Reporter.getOutput(result);
	        if (!reporterMessages.isEmpty()) {
	            writer.print("<tr><th");
	            if (parameterCount > 1) {
	                writer.print(" colspan=\"");
	                writer.print(parameterCount);
	                writer.print("\"");
	            }
	            writer.print(">Messages</th></tr>");

	            writer.print("<tr><td");
	            if (parameterCount > 1) {
	                writer.print(" colspan=\"");
	                writer.print(parameterCount);
	                writer.print("\"");
	            }
	            writer.print(">");
	            writeReporterMessages(reporterMessages);
	            writer.print("</td></tr>");
	        }

	        // Write exception (if any)
	        Throwable throwable = result.getThrowable();
	        if (throwable != null) {
	            writer.print("<tr><th");
	            if (parameterCount > 1) {
	                writer.print(" colspan=\"");
	                writer.print(parameterCount);
	                writer.print("\"");
	            }
	            writer.print(">");
	            writer.print((result.getStatus() == ITestResult.SUCCESS ? "Expected Exception"
	                    : "Exception"));
	            writer.print("</th></tr>");

	            writer.print("<tr><td");
	            if (parameterCount > 1) {
	                writer.print(" colspan=\"");
	                writer.print(parameterCount);
	                writer.print("\"");
	            }
	            writer.print(">");
	            writeStackTrace(throwable);
	            writer.print("</td></tr>");
	        }

	        writer.print("</table>");
	        writer.print("<p class=\"totop\"><a href=\"#summary\">back to summary</a></p>");
	    }

	    protected void writeReporterMessages(List<String> reporterMessages) {
	        writer.print("<div class=\"messages\">");
	        Iterator<String> iterator = reporterMessages.iterator();
	        assert iterator.hasNext();
	        writer.print(Utils.escapeHtml(iterator.next()));
	        while (iterator.hasNext()) {
	            writer.print("<br/>");
	            writer.print(Utils.escapeHtml(iterator.next()));
	        }
	        writer.print("</div>");
	    }

	    protected void writeStackTrace(Throwable throwable) {
	        writer.print("<div class=\"stacktrace\">");
//	        writer.print(Utils.stackTrace(throwable, true)[0]);
	        writer.print("</div>");
	    }

	    /**
	     * Writes a TH element with the specified contents and CSS class names.
	     *
	     * @param html       the HTML contents
	     * @param cssClasses the space-delimited CSS classes or null if there are no
	     *                   classes to apply
	     */
	    protected void writeTableHeader(String html, String cssClasses) {
	        writeTag("th", html, cssClasses);
	    }

	    /**
	     * Writes a TD element with the specified contents.
	     *
	     * @param html the HTML contents
	     */
	    protected void writeTableData(String html) {
	        writeTableData(html, null);
	    }

	    /**
	     * Writes a TD element with the specified contents and CSS class names.
	     *
	     * @param html       the HTML contents
	     * @param cssClasses the space-delimited CSS classes or null if there are no
	     *                   classes to apply
	     */
	    protected void writeTableData(String html, String cssClasses) {
	        writeTag("td", html, cssClasses);
	    }

	    /**
	     * Writes an arbitrary HTML element with the specified contents and CSS
	     * class names.
	     *
	     * @param tag        the tag name
	     * @param html       the HTML contents
	     * @param cssClasses the space-delimited CSS classes or null if there are no
	     *                   classes to apply
	     */
	    protected void writeTag(String tag, String html, String cssClasses) {
	        writer.print("<");
	        writer.print(tag);
	        if (cssClasses != null) {
	            writer.print(" class=\"");
	            writer.print(cssClasses);
	            writer.print("\"");
	        }
	        writer.print(">");
	        writer.print(html);
	        writer.print("</");
	        writer.print(tag);
	        writer.print(">");
	    }

	    /**
	     * Groups {@link TestResult}s by suite.
	     */
	    protected static class SuiteResult {
	        private final String suiteName;
	        private final List<TestResult> testResults = Lists.newArrayList();

	        public SuiteResult(ISuite suite) {
	            suiteName = suite.getName();
	            for (ISuiteResult suiteResult : suite.getResults().values()) {
	                testResults.add(new TestResult(suiteResult.getTestContext()));
	            }
	        }

	        public String getSuiteName() {
	            return suiteName;
	        }

	        /**
	         * @return the test results (possibly empty)
	         */
	        public List<TestResult> getTestResults() {
	            return testResults;
	        }
	    }

	    /**
	     * Groups {@link ClassResult}s by test, type (configuration or test), and
	     * status.
	     */
	    protected static class TestResult {
	        /**
	         * Orders test results by class name and then by method name (in
	         * lexicographic order).
	         */
	        protected static final Comparator<ITestResult> RESULT_COMPARATOR = new Comparator<ITestResult>() {
	            @Override
	            public int compare(ITestResult o1, ITestResult o2) {
	                int result = o1.getTestClass().getName()
	                        .compareTo(o2.getTestClass().getName());
	                if (result == 0) {
	                    result = o1.getMethod().getMethodName()
	                            .compareTo(o2.getMethod().getMethodName());
	                }
	                return result;
	            }
	        };

	        private final String testName;
	        private final List<ClassResult> failedConfigurationResults;
	        private final List<ClassResult> failedTestResults;
	        private final List<ClassResult> skippedConfigurationResults;
	        private final List<ClassResult> skippedTestResults;
	        private final List<ClassResult> passedTestResults;
	        private final int failedTestCount;
	        private final int skippedTestCount;
	        private final int passedTestCount;
	        private final long duration;
	        private final String includedGroups;
	        private final String excludedGroups;

	        public TestResult(ITestContext context) {
	            testName = context.getName();

	            Set<ITestResult> failedConfigurations = context
	                    .getFailedConfigurations().getAllResults();
	            Set<ITestResult> failedTests = context.getFailedTests()
	                    .getAllResults();
	            Set<ITestResult> skippedConfigurations = context
	                    .getSkippedConfigurations().getAllResults();
	            Set<ITestResult> skippedTests = context.getSkippedTests()
	                    .getAllResults();
	            Set<ITestResult> passedTests = context.getPassedTests()
	                    .getAllResults();

	            failedConfigurationResults = groupResults(failedConfigurations);
	            failedTestResults = groupResults(failedTests);
	            skippedConfigurationResults = groupResults(skippedConfigurations);
	            skippedTestResults = groupResults(skippedTests);
	            passedTestResults = groupResults(passedTests);

	            failedTestCount = failedTests.size();
	            skippedTestCount = skippedTests.size();
	            passedTestCount = passedTests.size();

	            duration = context.getEndDate().getTime() - context.getStartDate().getTime();

	            includedGroups = formatGroups(context.getIncludedGroups());
	            excludedGroups = formatGroups(context.getExcludedGroups());
	        }

	        /**
	         * Groups test results by method and then by class.
	         */
	        protected List<ClassResult> groupResults(Set<ITestResult> results) {
	            List<ClassResult> classResults = Lists.newArrayList();
	            if (!results.isEmpty()) {
	                List<MethodResult> resultsPerClass = Lists.newArrayList();
	                List<ITestResult> resultsPerMethod = Lists.newArrayList();

	                List<ITestResult> resultsList = Lists.newArrayList(results);
	                Collections.sort(resultsList, RESULT_COMPARATOR);
	                Iterator<ITestResult> resultsIterator = resultsList.iterator();
	                assert resultsIterator.hasNext();

	                ITestResult result = resultsIterator.next();
	                resultsPerMethod.add(result);

	                String previousClassName = result.getTestClass().getName();
	                String previousMethodName = result.getMethod().getMethodName();
	                while (resultsIterator.hasNext()) {
	                    result = resultsIterator.next();

	                    String className = result.getTestClass().getName();
	                    if (!previousClassName.equals(className)) {
	                        // Different class implies different method
	                        assert !resultsPerMethod.isEmpty();
	                        resultsPerClass.add(new MethodResult(resultsPerMethod));
	                        resultsPerMethod = Lists.newArrayList();

	                        assert !resultsPerClass.isEmpty();
	                        classResults.add(new ClassResult(previousClassName,
	                                resultsPerClass));
	                        resultsPerClass = Lists.newArrayList();

	                        previousClassName = className;
	                        previousMethodName = result.getMethod().getMethodName();
	                    } else {
	                        String methodName = result.getMethod().getMethodName();
	                        if (!previousMethodName.equals(methodName)) {
	                            assert !resultsPerMethod.isEmpty();
	                            resultsPerClass.add(new MethodResult(resultsPerMethod));
	                            resultsPerMethod = Lists.newArrayList();

	                            previousMethodName = methodName;
	                        }
	                    }
	                    resultsPerMethod.add(result);
	                }
	                assert !resultsPerMethod.isEmpty();
	                resultsPerClass.add(new MethodResult(resultsPerMethod));
	                assert !resultsPerClass.isEmpty();
	                classResults.add(new ClassResult(previousClassName,
	                        resultsPerClass));
	            }
	            return classResults;
	        }

	        public String getTestName() {
	            return testName;
	        }

	        /**
	         * @return the results for failed configurations (possibly empty)
	         */
	        public List<ClassResult> getFailedConfigurationResults() {
	            return failedConfigurationResults;
	        }

	        /**
	         * @return the results for failed tests (possibly empty)
	         */
	        public List<ClassResult> getFailedTestResults() {
	            return failedTestResults;
	        }

	        /**
	         * @return the results for skipped configurations (possibly empty)
	         */
	        public List<ClassResult> getSkippedConfigurationResults() {
	            return skippedConfigurationResults;
	        }

	        /**
	         * @return the results for skipped tests (possibly empty)
	         */
	        public List<ClassResult> getSkippedTestResults() {
	            return skippedTestResults;
	        }

	        /**
	         * @return the results for passed tests (possibly empty)
	         */
	        public List<ClassResult> getPassedTestResults() {
	            return passedTestResults;
	        }

	        public int getFailedTestCount() {
	            return failedTestCount;
	        }

	        public int getSkippedTestCount() {
	            return skippedTestCount;
	        }

	        public int getPassedTestCount() {
	            return passedTestCount;
	        }

	        public long getDuration() {
	            return duration;
	        }

	        public String getIncludedGroups() {
	            return includedGroups;
	        }

	        public String getExcludedGroups() {
	            return excludedGroups;
	        }

	        /**
	         * Formats an array of groups for display.
	         */
	        protected String formatGroups(String[] groups) {
	            if (groups.length == 0) {
	                return "";
	            }

	            StringBuilder builder = new StringBuilder();
	            builder.append(groups[0]);
	            for (int i = 1; i < groups.length; i++) {
	                builder.append(", ").append(groups[i]);
	            }
	            return builder.toString();
	        }
	    }

	    /**
	     * Groups {@link MethodResult}s by class.
	     */
	    	protected static class ClassResult {
	        private final String className;
	        private final List<MethodResult> methodResults;

	        /**
	         * @param className     the class name
	         * @param methodResults the non-null, non-empty {@link MethodResult} list
	         */
	        public ClassResult(String className, List<MethodResult> methodResults) {
	            this.className = className;
	            this.methodResults = methodResults;
	        }

	        public String getClassName() {
	            return className;
	        }

	        /**
	         * @return the non-null, non-empty {@link MethodResult} list
	         */
	        public List<MethodResult> getMethodResults() {
	            return methodResults;
	        }
	    }

	    /**
	     * Groups test results by method.
	     */
	    protected static class MethodResult {
	        private final List<ITestResult> results;

	        /**
	         * @param results the non-null, non-empty result list
	         */
	        public MethodResult(List<ITestResult> results) {
	            this.results = results;
	        }

	        /**
	         * @return the non-null, non-empty result list
	         */
	        public List<ITestResult> getResults() {
	            return results;
	        }
	    }

	    /*
	    Methods to improve time display on report
	     */
	    protected String getDateAsString() {
	        Date date = new Date();
	        sdfdate.setTimeZone( TimeZone.getTimeZone( timeZone ) );
	        return sdfdate.format( date );
	    }

	    protected String parseUnixTimeToTimeOfDay( long unixSeconds ) {
	        Date date = new Date( unixSeconds );
	        sdftime.setTimeZone( TimeZone.getTimeZone( timeZone ) );
	        return sdftime.format( date );
	    }

	    protected double millisecondsToSeconds( long ms ) {
	        return new BigDecimal( ms/1000.00 ).setScale( 2, RoundingMode.HALF_UP ).doubleValue();
	    }
		
	    @AfterMethod
		public void Teardown() {
			if (driver != null) {
	            driver.quit();
	        }
		}

	}
